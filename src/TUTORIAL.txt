TUTORIAL

I. First simple example (only one machine, running online)

To check if alias "foo1" already has its signatures in the blockchain
we use the RPC "bclist" (means blockchainlist):

  @onlinemachine: ./bitcoind -testnet bclist foo1
  {
      "fRegistered" : false
  }

This means that "foo1" is not yet registered in the blockchain. We now
build a BCPKI-style certificate (BCPKI = blockchain-PKI) that can
later be signed by the alias "foo1" within the blockchain. We first
generate a payment address to be written into the cert:

  @onlinemachine: ./bitcoind -testnet getnewaddress
  mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh

We then create the cert in a text editor by filling out the
YAML-template cert_template.yml. We save it as the file foo1.yml
containing:

  version: 0.1
  data:
    subjectname: Foo Inc.
    contacts: 
     - type: EMAIL
       value: contact@foo.com 
     - type: URL  
       value: "http://foo.com"
    paymentkeys:
      - algorithm:
         type: STATIC_BTCADDR
        value: [ mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh ]

The .yml certificate is is turned into a protobuf:

  @onlinemachine: makecert.py foo1.yml
  data {
    version: "0.1"
    subjectname: "Foo Inc."
    contacts {
      type: EMAIL
      value: "foo@fooinc.com"
    }
    contacts {
      type: URL
      value: "http://www.fooinc.com"
    }
    paymentkeys {
      usage: PAYMENT
      algorithm {
        type: STATIC_BTCADDR
      }
      value: "mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh"
    }
  }
  
  binary cert written to: ~/.bitcoin/testnet3/bcerts/foo1.bcrt
  hash of data part is: 3119fff8f75b59d6600511dd3f49fd007d380a87

Note that makecert.py placed the protobuf certificate into the local
"bcerts" directory where bitcoind will find it. We can let bitcoind
sign any certificate that is stored in .bitcoin/testnet3/bcert using
the RPC bcsign (bcsign = blockchainsign):

  @onlinemachine: ./bitcoind -testnet bcsigncert foo1
  {
      "nFee" : 0.00050000,
      "txid" : "f996c23796b771e244ed9e7e240f84c325161309acbe0615a9fb3537ecd9011b"
  }

After the transaction gets mined we can verify this signature within
the blockchain.  While we wait for a confirmation lets take the time
to look at some other information that bitcoind has stored.

  @onlinemachine: ./bitcoind -testnet aliasdump foo1
  {
      "normalized" : "v0.3_F01",
      "bcvalue" : "28e4898c7041ed937c17110806024528ad103afe000000000000000000000000",
      "pubkey" : "021f5e6d618cf1beb74c79f42b0aae796094b3112bbe003209a2c1f757f1215bfd",
      "id" : "62501937cb578cbba4b1a81fe14cccd7eacec9e3",
      "addr" : "mpUnUCHAdfyTCRgQ56UMh8K8tmtx2Vr9GH",
      "owner account" : "v0.3_F01_OWNER"
  }

Explanation:
- normalized is the alias name after normalization (uppercase, etc.)
  prepended by the current version number that bitcoind uses for its
  blockchain signatures
- bcvalue is the Hash160 of normalized
- pubkey is the curve point bcvalue*G where G is the base point and
  bcvalue is interpreted as a little-endian number
- id is the Hash160 of pubkey
- addr is the base58-check-encoding (bitcoin address) of id
- owner_account is an account created in our wallet thats holds the
  keys necessary for revocation of the signature (called the "owners"
  of "foo1")
Note that the file name that makecert.py created was in fact id.bcrt. We
check what owners bcsign has created for us:

  @onlinemachine: ./bitcoind -testnet getaddressesbyaccount v0.3_F01_OWNER
  [
      "mixuBTFxEhMPCtBvQnLik9BVzKkMZu37S8"
  ]

We look at further information that bcsign has stored in our wallet
along with the committed transaction:

  @onlinemachine: ./bitcoind -testnet getaddressesbyaccount v0.3_F01_OWNER
  {
      [...]
      "BCPKI" : "v0.3",
      "bcvalues" : "28e4898c7041ed937c17110806024528ad103afe000000000000000000000000 122a9ee74a75b8490350dc406b05a88b0a010834000000000000000000000000 ",
      "owners" : "03c6b20d5da48e0db680326671d315ee4e3e28c718c9fc689ad89e0cbff82255ad ",
      "signature" : "foo1",
      [...]
  }

We see that this transaction was meant for a signature of "foo1" in
version "v0.3". Under "bcvalues" we see two values that were signed,
one we recognize as the bcvalue of "foo1" (see aliasdump above) and
the other as the hash of the data part of our certificate (see
mycert.py above).  Under "owners" we see the pubkey that belongs to
the address mixuBTFxEhMPCtBvQnLik9BVzKkMZu37S8 (see
getaddressesbyaccount above). (You can check this with an address
calculator..) Note that the two bcvalues are the private keys to
pubkeys that appear in the actual transaction (use getrawtransaction
and decoderawtransaction to check this, if you want). These two values
are needed later to revoke the signature by redeeming the outputs.

When the transactions got confirmed we can verify the signature.  The
RPC bcverify (means blockchainverify) lets bitcoind verify any cert
that is stored under .bitcoin/testnet3/bcerts:

  @onlinemachine: ./bitcoind -testnet bcverify foo1
  {
      "fSigned" : true,
      "txid" : "f996c23796b771e244ed9e7e240f84c325161309acbe0615a9fb3537ecd9011b",
      "confirmations" : 1,
      "strTime" : "2013-01-26T13:08:03"
  }

Now we wish to send funds directly to a certificate which is stored under .bitcoin/testnet3/bcerts.
The RPC sendtoalias looks up that cert, verifies it, extracts the address, and sends the funds there:

  @onlinemachine: ./bitcoind -testnet sendtoalias foo1 1
  {
      "nConfirmations" : 4,
      "static" : "mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh",
      "txid" : "2161bf7d870e5395b56c7aa8628ecf08e4c9a5ccc4859c5558da9b30bc04b9a2"
  }

Note that mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh is indeed the pubkey that
we placed in the certificate earlier as a static bitcoin address. This
tells that at the time of sending the blockchain signature on foo1's
certificate had 4 confirmations. The transactions gets labelled in our
wallet like this:

@offlinemachine: ./bitcoind -testnet gettransaction 2161bf7d870e5395b56c7aa8628ecf08e4c9a5ccc4859c5558da9b30bc04b9a2
{
    [...]
    "to" : "v0.3_F01<static> = mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh",
    [...]
}
