Note that the file name that makecert.py created was in fact id.bcrt. We
check what owners bcsign has created for us:

  @onlinemachine: ./bitcoind -testnet getaddressesbyaccount v0.3_F01_OWNER
  [
      "mixuBTFxEhMPCtBvQnLik9BVzKkMZu37S8"
  ]

We look at further information that bcsign has stored in our wallet
along with the committed transaction:

  @onlinemachine: ./bitcoind -testnet getaddressesbyaccount v0.3_F01_OWNER
  {
      [...]
      "BCPKI" : "v0.3",
      "bcvalues" : "28e4898c7041ed937c17110806024528ad103afe000000000000000000000000 122a9ee74a75b8490350dc406b05a88b0a010834000000000000000000000000 ",
      "owners" : "03c6b20d5da48e0db680326671d315ee4e3e28c718c9fc689ad89e0cbff82255ad ",
      "signature" : "foo1",
      [...]
  }

We see that this transaction was meant for a signature of "foo1" in
version "v0.3". Under "bcvalues" we see two values that were signed,
one we recognize as the bcvalue of "foo1" (see aliasdump above) and
the other as the hash of the data part of our certificate (see
mycert.py above).  Under "owners" we see the pubkey that belongs to
the address mixuBTFxEhMPCtBvQnLik9BVzKkMZu37S8 (see
getaddressesbyaccount above). (You can check this with an address
calculator..) Note that the two bcvalues are the private keys to
pubkeys that appear in the actual transaction (use getrawtransaction
and decoderawtransaction to check this, if you want). These two values
are needed later to revoke the signature by redeeming the outputs.

When the transactions got confirmed we can verify the signature.  The
RPC bcverify (means blockchainverify) lets bitcoind verify any cert
that is stored under .bitcoin/testnet3/bcerts:

  @onlinemachine: ./bitcoind -testnet bcverify foo1
  {
      "fSigned" : true,
      "txid" : "f996c23796b771e244ed9e7e240f84c325161309acbe0615a9fb3537ecd9011b",
      "confirmations" : 1,
      "strTime" : "2013-01-26T13:08:03"
  }

Now we wish to send funds directly to a certificate which is stored under .bitcoin/testnet3/bcerts.
The RPC sendtoalias looks up that cert, verifies it, extracts the address, and sends the funds there:

  @onlinemachine: ./bitcoind -testnet sendtoalias foo1 1
  {
      "nConfirmations" : 4,
      "static" : "mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh",
      "txid" : "2161bf7d870e5395b56c7aa8628ecf08e4c9a5ccc4859c5558da9b30bc04b9a2"
  }

Note that mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh is indeed the pubkey that
we placed in the certificate earlier as a static bitcoin address. This
tells that at the time of sending the blockchain signature on foo1's
certificate had 4 confirmations. The transactions gets labelled in our
wallet like this:

@offlinemachine: ./bitcoind -testnet gettransaction 2161bf7d870e5395b56c7aa8628ecf08e4c9a5ccc4859c5558da9b30bc04b9a2
{
    [...]
    "to" : "v0.3_F01<static> = mrMyF68x19kAc2byGKqR9MLfdAe1t5MPzh",
    [...]
}
